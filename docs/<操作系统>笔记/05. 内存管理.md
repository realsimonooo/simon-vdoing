---
title:  内存管理
date: 2021-04-25 22:49:48
permalink: /pages/31e0aa/
categories:
  - <操作系统>笔记
---


## :one:存储管理的功能



### 虚拟存储器

设计程序时，不需要考虑实际内存的大小等信息，由**操作系统统一进行内存和外存管理**，通过**内存管理**手段为用户提供比实际内存大得多的存储器。

![image-20210425225330166](https://gitee.com/realsimonooo/blog-image/raw/master/uPic/2cxycs.png)

+ **虚拟存储器**：进程中的**目标代码、数据**等的虚拟地址组成的虚拟空间；

  不考虑物理存储器的大小和信息存放的实际位置，只考虑每个进程中互相关联的信息的**相对位置**；



**程序运行前的步骤**：

+ 从输入队列中选一个进程装入内存，进程在执行时访问内存中的**指令和数据**；
+ 进程终止时，**释放地址空间**；



### 地址空间

**逻辑地址空间与物理地址空间**

**内存管理的重要环节：**将逻辑地址空间捆绑到**单独的**物理地址空间；

+ **逻辑地址**：CPU所生成的地址集合；
+ **物理地址**：内存单元中的地址集合；



### 地址变换

>  **地址捆绑的步骤**：
>
> <img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/esbLje.png" alt="image-20210425230202415" style="zoom: 25%;" />
>
> + 编译时间
> + 加载时间
> + 执行时间



#### 地址变换的两个问题

1. **虚拟地址空间划分**问题

   虚拟地址空间的划分使得🔗编译链接程序可以把不同的程序模块**链接**到一个**统一的虚拟空间**中；

   划分与计算机系统结构有关；

2. **地址重定位**问题

   把虚拟空间中已经**链接和划分**好的内容装入内存，并将虚拟地址**映射**为内存地址空间；



#### 地址变化的方法

:one:**静态地址重定位**

​	在虚拟空间程序执行之前，由**装配程序**完成的**地址映射工作**；

​	特点：

+ 不需要硬件支持；
+ 无法实现**虚拟存储器**；
+ 必须占有**连续的**内存空间，难以做到程序和数据**共享**；



:two:**动态地址重定位**

​	在程序执行过程中，CPU访问内存之前，**将要访问的程序或者数据地址转换为内存地址**；

+ 依靠硬件地址变换机构完成；

+ 需要一个(或多个)基地址寄存器**BR**和一个(或多个)程序虚拟寄存器**VR**，可得指令或数据的内存地址**MA**与虚拟地址的关系为：<mark>$MA=(BR)+(VR)$</mark>；

  > **(BR)**、**(VR)**分别指**BR**和**VR**寄存器中的内容；

<img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/J1P7tM.png" alt="image-20210425232039020" style="zoom:50%;" />

​	**内存管理单元 MMU**

+ **硬件设备**可以实现在**程序运行时**从虚拟地址到物理地址的**映射**；
+ 用户进程所生成的地址**VR在送交内存之前**，都将加上重定位寄存器（**BR**），得到实际访问的物理地址**MA**；

:star:优点：

+ 对内存进行**非连续分配**；
+ 提供了**实现虚拟存储器的基础**，部分的**动态分配内存**；
+ 有利于**程序段的共享**；



### 内外存数据控制

#### 内存的信息共享和保护

常用的保护法有：

+ **硬件保护法 / 上下界保护法**

  > 为每个进程设置一对上下界寄存器，其中装有被保护程序和数据的**起始地址和终止地址**；
  >
  > <img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/X0htjA.png" alt="image-20210425233307488" style="zoom:25%;" />

+ **保护键法 / 软件保护法**

  > 为每个保护存储块分配**保护键**开关制，对不同的进程赋予不同的开关码与之匹配。<img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/cGLrrv.png" alt="image-20210425233322495" style="zoom:33%;" />

+ **软硬件结合保护法** 将界限寄存器与CPU用户太或核心工作方式相结合的保护方法；

  > 这种保护方法之下，用户态进程只能访问界限寄存器所规定范围内的内存部分，核心态进程可以访问整个内存地址空间；

## :two:分区存储管理

+ **固定分区法**

  > 在内存中划分大小不等的区域，可以分为**长作业区和短作业区**，分区一旦划分结束，在整个执行过程中每个分区的**长度**和内存的总分区**个数**保持不变；
  >
  > ![image-20210426102544380](https://gitee.com/realsimonooo/blog-image/raw/master/uPic/vGalEx.png)

+ **动态分区法**

  > 在作业执行前不建立分区，**是在作业的处理过程中进行的**，**其大小可随作业或进程对内存的要求而改变**。
  >
  > :star:改变了固定分区法那种即使是小作业也要占据大分区的**浪费现象**，**提高了内存的利用率**；
>
  > <mark>牺牲了时间，换得了空间</mark>

  采用动态分区法，除了操作系统常驻内存部分，**只有一个空闲区**。分配程序将该区**依次**划分给调度选中的作业或进程：

  <img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/Z5mBHP.png" alt="image-20210426103921411" style="zoom:25%;" />

  随着进程执行，出现一系列的分配和释放、内存的回收和合并：（内存分配变化过程：**最先适应算法**(FF)）<img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/xOPNbW.png" alt="image-20210426104316896" style="zoom:33%;" />

+ **可用表、自由链、请求表**：

  <img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/aMX9md.png" alt="image-20210426105725883" style="zoom:33%;" />

  与固定分区法相同，动态分区法也要使用说明表等数据结构对内存进行管理；除了分区说明表，**还把内存中的可用分区单独构成可用分区表或可用自由链**，**描述内存资源**。**资源请求表由请求内存资源的作业或进程构成。**

  + **可用表**：每个表目记录一个**空闲区**。表格结构管理过程简单，但表的大小难以确定，要占用一部分内存；
  + **自由链**：利用每个内存空闲区的头几个单元存放**本空闲去的大小**及**下个空闲区的起始地址**讲所有空闲区链链接去来； 查找时比可用表困难，但节省内存区空间；
  + 请求表：描述请求内存资源的作业或进程号以及所请求内存大小；

  **利于分区查找和回收**；

### 分区分配和回收

+ **固定分区的分配和回收**

  分配：用户程序装入执行时，通过请求表提出内存分配的要求和所要求的内存空间大小。存储管理程序根据请求表查询分区说明表，**找到满足要求的空闲分区**。

  回收：将不使用的分区**设置对应的未使用状态**；

+ **动态分区的分配和回收**

  要解决三个问题：

  + 从可用表或自由链中，**寻找合适的空闲区进行分配**；

  + 分配后**更新**可用表或自由链；

  + 进程或作业**释放内存**时，和相邻的空闲区进行**链接合并**，**更新可用表和自由链**；

  从可用表或自由链中**寻找空闲区**的常用方法：

  + **最先适应算法**：

    > 要求按照可用表或自由链 **按起始地址递增的次序**排列。特点：一旦找到 **大于等于所要求内存长度的分区**就结束探索；

  + **最佳适应算法**

    > 要求按照 **从小到大的次序**组成空闲区可用表或自由链；

  + **最坏适应算法**

    > 要求空闲区按照 **大小递减的顺序**组成空闲区可用表或自由链。

  **三种方法比较**：

  1. 搜索速度最快：**最先适应算法**；
  2. 找到的空闲区最佳：**最佳适应算法**；
  3. 不留下碎片空闲区：**最坏适应算法**；

### 连续分配内存

**多分区分配**：

+ **孔**：能做为一大块可用内存，在内存中有各种大小的孔可供分配；
+ 当有新进程需要内存时，为该内存查找足够大的孔；
+ 操作系统维护：分配内存，自由内存；

### 碎片

+ **外部碎片**：

  当所有总的内存之和可以满足要求，但不连续，就出现了外部碎片；

  解决方案：

  > 1. 紧缩；
  > 2. 分页；
  > 3. 分段

+ **内部碎片**：

  分配给作业的存储空间中未被利用的部分；

  内部碎片由于这部分内存存在**进程分区之内**，无法被其它进程使用；

### 内外存数据控制

+ 控制内外存数据传输：

  + 用户程序控制：**覆盖**；
  + 操作系统控制：**交换**；

+ 内存的分配和回收：

  **存储管理模块为每个并发执行的进程分配内存空间**，当进程执行结束后，**存储管理模块又要及时回收所有占有的内存资源**，一边分配给其它进程；

## :three:覆盖与交换

是多道环境用来扩充内存的两种方法；

### 覆盖

一个程序并不需要一开始就把它全部的指令和数据都装入内存中执行；**把程序分成若干个功能上相对独立的程序段，按照程序的逻辑结构让那些不会同时执行的程序段共享一块内存区**；<img src="https://gitee.com/realsimonooo/blog-image/raw/master/uPic/eoKCml.png" alt="image-20210426113503014" style="zoom:33%;" />

+ 优点：
  + 实现多个作业或进程对**内存的共享**；
  + 硬件支持少，管理算法简单，**容易实现**；
+ 缺点：
  + **内存利用率不高**，存储器中可能存在从未使用过的信息；
  + 作业或进程的大小受到**分区大小的控制**；
  + 无法实现**各个分区之间的信息共享**；
+ 技术要求：
  + 程序员要提供清楚的**覆盖结构**；
  + 程序员要求懂得系统和**内存的内部结构与地址划分**；

### 交换

进程可以暂时从内存中**整体写入外存交换区**，再从**外存交换区**中调入**指定的程序或数据**到内存中，并让其执行的一种**内存拓展技术**；

+ **备份存储**：足够大的快速磁盘空间用来保存所有用户的所有内存空间的备份，并提供对内存映射的直接访问；

+ **滚入滚出** ：基于 **优先权调度算法**，如果一个 **高优先权的进程** 来了，内存管理将先滚出 **低优先权的进程**，然后再滚入 **高优先权的进程** 执行；

+ **交换总时间**=传输时间+平均延迟时间+交换程序时间；

  