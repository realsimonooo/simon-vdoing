---
title: BOM
date: 2020-07-01 17:22:18
permalink: /pages/ae3a3a/
categories:
  - <JavaScript>笔记
---
# `BOM`

`BOM（Browser Object Model）`即==浏览器对象模型==，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是`window`。

| `DOM`                            | `BOM`                                      |
| -------------------------------- | ------------------------------------------ |
| 文档对象模型                     | 浏览器对象模型                             |
| 把「文档」当做一个「对象」来看待 | 把「浏览器」当做一个「对象」来看待         |
| 顶级对象是document               | 顶级对象是window                           |
| 操作页面元素                     | 浏览器==窗口交互==的一些对象               |
| 有W3C 标准规范                   | 浏览器厂商在各自浏览器上定义的，兼容性较差 |



## `BOM`构成

+ window对象是浏览器的顶级对象，有双重角色；
  + 是JS 访问浏览器窗口的一个接口；
  + 是一个**全局**对象。
    + 定义在**全局作用域**中的变量、函数都会变成window对象的属性和方法

+ 在调用的时候**可以省略window**，前面学习的对话框都属于window 对象方法，如`alert()\prompt()`等。
  + window下的一个特殊属性`window.name`



## `window `对象的常见事件

### 窗口加载事件

```js
window.onload = function(){}
// 或者
window.addEventListener("load",function(){});
```

+ `window.onload` 是窗口(页面）加载事件,当文档内容**完全加载完成**会触发该事件(包括图像、脚本文件、CSS文件等), 就调用的处理函数。
  +  有了`window.onload `就可以把`JS `代码写到页面元素的上方，因为`onload` 是等页面内容**全部加载完毕**，再去执行处理函数；
  + `window.onload `传统注册事件方式==只能写一次==，如果有多个，会以最后一个`window.onload `为准；
  + 如果使用addEventListener 则**没有限制**；



```js
document.addEventListener('DOMContentLoaded',function(){})
```

+ DOMContentLoaded事件触发时，**仅当DOM加载完成**，不包括样式表，图片，flash等等；
+ IE9以上才支持；
+ 如果**页面的图片很多**的话, 从用户访问到onload触发可能需要较长的时间,交互效果就不能实现，必然影响用户的体验，**此时用DOMContentLoaded 事件比较合适**。



### 调整窗口大小事件

```js
window.onresize = function(){}
window.addEventListener("resize",function(){});
```

+ `window.onresize` 是**调整窗口大小**加载事件,  当触发时就调用的处理函数。
  + 只要**窗口大小发生像素变化**，就会触发这个事件；
  + 我们经常利用这个事件完成**响应式布局**。
    2. `window.innerWidth` 当前屏幕的**宽度**；





## 定时器

### 两种定时器

`window `对象提供了两种定时器：

#### `setTimeout()`

```js
window.setTimeout(调用函数, [延迟的毫秒数]);
```

+ 用于设置一个定时器，该定时器在定时器**到期**后**执行**调用函数。
  + window 可以省略。
  + 这个调用函数可以*直接写函数**，或者**写函数名**或者**采取字符串‘函数名()'**三种形式。第三种不推荐；
  + 延迟的毫秒数省略默认是`0`，如果写，必须是**毫秒**。
  + 因为定时器可能有很多，所以我们经常**给定时器赋值一个标识符。**
  
+ 调用函数也称回调函数(`callback`)

  + 普通函数是按照代码顺序直接调用；
  + 而这个函数，需要等待时间，**时间到了才去调用**这个函数，因此称为回调函数。
  + `element.onclick = function(){} `  或者`element.addEventListener(“click”, fn); `  里面的函数是**回调函数**。

+ **停止`setTimeout()`定时器**

  + ```js
    window.clearTimeout(timeoutID)
    	// 参数就是定时器的标识符
    ```

    + 取消了先前通过调用`setTimeout()`建立的定时器。

#### `setInterval()`

```js
window.setInterval(回调函数, [间隔的毫秒数]);
```

+ 重复调用一个函数，每隔一个时间就会去调用一个回调函数；

+ **停止`setInterval()` 定时器**

  + ```js
    window.clearInterval(intervalID);
    	// 参数就是定时器的标识符
    ```

    + 取消了先前通过调用`setInterval()`建立的定时器。

### `this`

+ 只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个**调用它的对象**；
+ 了解一下几个this指向:
  + 全局作用域或者普通函数中`this`指向全局对象`window`（注意定时器里面的`this`指向`window`）;
  + 方法调用中谁调用this指向谁；
  + 构造函数中`this`指向构造函数的实例；



# `JS`执行机制

### `JS`单线程

+ 单线程，也就是说，同一个时间只能做一件事。
+ JavaScript 是为处理页面中用户的交互，以及操作DOM 而诞生的。比如我们对
  某个DOM 元素进行添加和删除操作，**不能同时进行**。**应该先进行添加，之后再删除**。

+ 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。这样所导致的问题是：如果JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

为了解决这个问题，利用多核CPU 的计算能力，HTML5 提出Web Worker 标准，允许JavaScript 脚本**创建多个线程**。于是，JS 中出现了**同步和异步**。

### 同步

前一个任务**结束后**再执行后一个任务，程序的执行顺序与任务的**排列顺序是一致的**、同步的。

+ 同步任务：同步任务都在主线程上执行，形成一个**执行栈**。

### 异步

在做这件事的同时，你还可以去处理其他事情；

+ 异步任务：通过回调函数实现的:
  + 三种类型的异步任务:
  + 1、普通事件，如`click`、`resize` 等
    2、资源加载，如`load`、`error` 等
    3、定时器，包括`setInterval`、`setTimeout` 等
  + 异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）;



+ 本质区别：这条流水线上各个流程的**执行顺序**不同。



