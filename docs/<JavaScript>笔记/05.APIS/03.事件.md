---
title: 事件
date: 2020-09-05 15:44:18
permalink: /pages/638932/
categories:
  - <JavaScript>笔记
---
# 注册事件

给元素添加事件，称为**注册事件或者绑定事件**。
注册事件有两种方式：传统方式和方法监听注册方式

| 传统注册方式                                                 | 方法监听注册方式                           |
| ------------------------------------------------------------ | ------------------------------------------ |
| 利用on 开头的事件`onclick` `<button onclick=“alert('hi~')”></button> btn.onclick = function() {}` | `addEventListener()` 它是一个方法          |
| 特点：注册事件的==唯一==性                                   | 同一个元素同一个事件可以注册==多个==监听器 |
| 同一个元素同一个事件只能设置一个处理函数最后注册的处理函数将会覆盖前面注册的处理函数 | 按注册顺序依次执行                         |

### `addEventListener`事情监听方式

```js
eventTarget.addEventListener(type, listener, useCapture)  
	// type 事件类型字符串 eg. click, mouseover *(没有on)
	// listener 指定的监听函数
	// useCapture 可选参数默认flase
```

### `attachEvent`事情监听方式

```js
eventTarget.attachEvent(eventNameWithOn, callback) 
	// eventNameWithOn 事件类型字符串 
	// callback (回调函数)事件处理函数，当目标触发事件回调函数被调用
```





```js
// 处理兼容性：
function addEventListener(element, eventName, fn) {
// 判断当前浏览器是否支持addEventListener 方法
if (element.addEventListener) {
element.addEventListener(eventName, fn);  // 第三个参数默认是false
} else if (element.attachEvent) {
element.attachEvent('on' + eventName, fn);
} else {
// 相当于element.onclick = fn;
element['on' + eventName] = fn;
} 
```

# 删除事件 / 解绑事件

1. 关键词 `removeEventListener` / `detachEvent`；

   ```js
   eventTarget.removeEventListener(type, listener[, useCapture]);
   eventTarget.detachEvent(eventNameWithOn, callback);
   ```

2. 传统注册事件的解绑

   ```js
   eventTarget.onclick = 'null';
   ```

   



# `DOM`事件流

+ 事件流描述的是从页面中**接收事件的顺序**。
+ 事件发生时会在元素**节点之间**按照特定的顺序**传播**，这个传播过程即**DOM 事件流**。

> DOM 事件流分为3个阶段：
> 1. 捕获阶段
>
>    由DOM 最顶层节点开始，然后**逐级向下**传播到到最具体的元素接收的过程；
>
> 2. 当前目标阶段
>
> 3. 冒泡阶段
>
>    事件开始时由最具体的元素接收，然后**逐级向上**传播到到DOM 最顶层节点的过程。

![image-20200630174727524](https://gitee.com/realsimonooo/blog-image/raw/master/uPic/ZtcaK8.png)



+ `js`代码中只能执行捕获或者冒泡其中的一个阶段；
+ `onclick` / `attachEvent`只能得到冒泡阶段；
+ `addEventListener(type, listener, useCapture)` 中`useCapture`的参数
  + `true`表示事件捕获阶段调用事件处理程序；
  + `false`/`默认无参数` 表示事件冒泡阶段调用事件处理程序；
+ ==实际上很少使用事件捕获，我们更关注**事件冒泡**；
+ 有些事件没有冒泡`onblur\onfocus\onmouseenter\onmouseleave`；



# 事件对象

```js
eventTarget.onclick = function(event){}
eventTarget.addEventListener('click',function(event){})
	// event 表示事件对象
	// event 是形参，系统设定为事件对象，不需要传递实参
```

+ `event` 表示事件的状态；如：键盘的状态、鼠标的位置、鼠标按钮的状态；
+ 事件发生后，跟事件相关的一系列信息数据的集合都放到这个**对象**里面，这个对象就是事件对象`event`，它有很多**属性和方法**。
  + 1.谁绑定了这个事件。
  + 2.鼠标触发事件的话，会得到鼠标的相关信息，如鼠标位置。
  + 3.键盘触发事件的话，会得到键盘的相关信息，如按了哪个键。



+ 注册事件时，`event`对象就会被系统自动创建，并以此传递给事件监听器，并以此传递给事件监听器（事件处理函数）；



### 事件对象的常见属性/方法

+ `e.target` / `this` 的区别

  `this` 是事件绑定的元素，这个函数的调用者（绑定这个事件的元素）；

  `e.target`是事件触发的元素；





# 阻止事件冒泡

+ 两种方式

  + 标准写法

    ```js
    e.stopPropagation()
    // 事件对象中的方法
    ```

  + 非标准

    ```js
    e.cancelBubble = true
    // 事件对象的属性修改
    ```



# 事件委托 (/代理/委派)

+ 大量重复的处理事件时，利用事件委托操作了一次`DOM`提高程序性能；
  + 原理：不是每个子节点单独设置事件监听器，而是将事件监听器设置在其**父节点**上，然后利用冒泡原理影响设置节点每个子节点；
+ 在`JQuery`称事件委派；